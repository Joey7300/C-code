/*3.八皇后问题。在一个8 x 8的国际象棋棋盘上放置8个皇后，使这些皇后之间不会相互攻击（在国际象棋中，皇后可以走直线和斜线）。请你编程输出所有的摆放方案。*/
/*先定义第一个皇后的位置，然后依次摆放剩下各个皇后，用if语句筛选出来符合条件的位置放上皇后，
利用for循环层层嵌套，最后得到所有可行的摆放方案*/
#include<stdio.h>
int main()
{
//定义一个计数器
 int count = 0;
 //因为按题意来说，每一行必须也只能放一个皇后，所以这边为了方便，就可以只定义皇后所在的列数
 //第一个皇后，从第一列到第八列找位置，可以假设其在第一行，其他皇后也以此类推
 for (int q1 = 0; q1 < 8; q1++)
 {
  for (int q2 = 0; q2 < 8; q2++)
  {
    //因为要求不同列以及不处在同一斜线，也就是列数不相同并且不是相邻列就可以了
   if (q1 == q2 || q1 == q2 + 1 || q1 == q2 - 1)
   {
    //如果符合条件，那么这个位置就不能用，跳过下面的部分，继续循环寻找，直到找到能用的位置
    continue;
   }
   for (int q3 = 0;q3 < 8; q3++)
   {
    //对第三个皇后也是一样，但是这里相对第一个皇后的位置判定有变化，但是也很好理解，接下来也与上面的循环查找同理
    if (q1 == q3 || q1 == q3 + 2 || q1 == q3-2
     || q2 == q3 || q2 == q3 + 1|| q2 == q3 - 1)
    {
     continue;
    }
    for (int q4 = 0; q4 < 8; q4++)
    {
     if (q1 == q4 || q1 == q4 + 3 || q1 == q4 - 3 
      || q2 == q4 || q2 == q4 + 2|| q2 == q4- 2 
      || q3 == q4 || q3 == q4 + 1 || q3== q4- 1)
     {
      continue;
     }
     for (int q5 = 0; q5 < 8; q5++)
     {
      if (q1 == q5 || q1 == q5 + 4 || q1 == q5 - 4 
       || q2 == q5 || q2 == q5 + 3|| q2 == q5 - 3 
       || q3 == q5 || q3 == q5 + 2 || q3 == q5- 2 
       || q4 == q5 || q4 == q5 + 1 || q4 == q5 - 1)
      {
       continue;
      }
      for (int q6 = 0; q6 < 8; q6++)
      {
       if (q1 == q6 || q1 == q6 + 5 || q1 == q6 - 5
        || q2 == q6 || q2 == q6 + 4 || q2 == q6 - 4
        || q3 == q6 || q3 == q6 + 3 || q3 == q6 - 3
        || q4 == q6 || q4 == q6 + 2 || q4 == q6 - 2
        || q5 == q6 || q5 == q6 + 1 || q5 == q6 - 1)
       {
        continue;
       }
       for (int q7 = 0; q7 < 8; q7++)
       {
        if (q1 == q7 || q1 == q7 + 6 || q1 == q7 - 6
         || q2 == q7 || q2 == q7 + 5 || q2 == q7 - 5
         || q3 == q7 || q3 == q7 + 4 || q3 == q7 - 4
         || q4 == q7 || q4 == q7 + 3 || q4 == q7 - 3
         || q5 == q7 || q5 == q7 + 2 || q5 == q7 - 2
         || q6 == q7 || q6 == q7 + 1 || q6 == q7 - 1)
        {
         continue;
        }
        for (int q8 = 0; q8 < 8; q8++)
        {
         if (q1 == q8 || q1 == q8 + 7 || q1 == q8 - 7
          || q2 == q8 || q2 == q8 + 6 || q2 == q8 - 6
          || q3 == q8 || q3 == q8 + 5 || q3 == q8 - 5
          || q4 == q8 || q4 == q8 + 4 || q4 == q8 - 4
          || q5 == q8 || q5 == q8 + 3 || q5 == q8 - 3
          || q6 == q8 || q6 == q8 + 2 || q6 == q8 - 2
          || q7 == q8 || q7 == q8 + 1 || q7 == q8 - 1)
         {
          continue;
         }
         //找到了一种可行的方法，那么计数器+1，打印各个皇后对应的列数，并回到对第一个皇后的循环语句中继续
         count++;
         printf("%d,%d,%d,%d,%d,%d,%d,%d\n", q1, q2, q3, q4,q5, q6, q7, q8);                        
        }
       }
      }
     }
    }
   }
  }
 }
 printf("一共有%d种方法", count);
 return 0;
}
